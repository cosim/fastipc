{
  "name": "Fastipc",
  "tagline": "在Windows下基于共享内存实现进程间通信",
  "body": "### FastIPC原理说明\r\n通过共享内存实现两个或多个进程进行数据的共享，要定义一个数据结构(MemBuf)。\r\n通过两个自定义Windows事件(evtWrited/evtReaded)，实现读写完成的通知。\r\n在共享数据结构中保存一个状态位(MemBuf.state)：记录当前内存状态，控制是否可读写。\r\n利用数组是共享数据结构最后一个字段(MemBuf.data)的特点，实现可配置缓存区大小。\r\n当传输数据大于缓存区大小时，会分段传输，此时会设置共享数据结构中数据的类型(MemBuf.msgType)和重组数据用的字段(MemBuf.packId)。\r\n服务端启动后，需要调用侦听方法(Server.startRead)，此时服务端阻塞在侦听方法内，直到有客户端写入数据后触发evtReaded事件。\r\n客户端创建后，直接写数据(Client.write)即可。\r\n服务端收到数据后，会从共享数据中读取数据生成分发用的数据(MemBlock)，并分发(Server.listener.onRead)数据，分发后服务端会自行#清理创建的分发数据。\r\n\r\n### FastIPC例子说明\r\n首先需要编译好TestFastIPCServer、TestFastIPCClient、FastIPC三个项目\r\n单击TestFastIPCServer后启动服务端。此时，服务端会进行一下操作：\r\n创建Server。这一步可以更改下blockSize以便验证数据分段传输。\r\n启动客户端（在TestFastIPCServer.exe所在目录的TestFastIPCClient.exe并启动）\r\n客户端自动启动后，会执行一下操作：\r\n从命令行解析serverName和blockSize参数\r\n创建客户端\r\n创建客户端的服务端(S2)，以便接收TestFastIPCServer发送的数据\r\n界面操作：服务端和客户端的界面是一样的（除了标题）。通过“发送消息”按钮进行数据的发送。\r\n\r\n### 使用FastIPC\r\n1、添加对FastIPC.dll和FastIPC.lib的引用<br/>\r\n2、将common/fastipc目录下头文件添加到项目。<br/>\r\n3、创建服务器<br/>\r\n<pre>\r\n    fastipc::Server server;     // IPC服务端\r\n    serverName = fastipc::genServerName();//指定服务名称，这里是uuid\r\n    DWORD blockSize=1024;// 指定缓存区的大小\r\n    server.create(serverName, blockSize);// 创建服务端\r\n    // 设置侦听器，以便对收到的数据进行处理\r\n    // MyReadListener是fastipc::ReadListener的实现类\r\n    server.setListener(new MyReadListener());\r\n    server.startRead();// 开始接收数据，此方法会阻塞当前线程\r\n</pre>\r\n4、创建客户端<br/>\r\n<pre>\r\n    fastipc::Client client;\t // IPC客户端\r\n    // 创建服务端，serverName和blockSize要与服务端保持一致\r\n    client.create(serverName, blockSize);   \r\n</pre>\r\n5、客户端发数据给服务器<br/>\r\n<pre>\r\n    std::string s =\"这是来自客户端的消息\";\r\n    client.write(LPSTR(s.c_str()), s.size());// 发送消息到服务端\r\n6、服务器接收并处理消息<br/>\r\n    // 定义数据处理类\r\n    class MyReadListener :public fastipc::ReadListener{\r\n        void onRead(fastipc::MemBlock* readed) override{            \r\n             if (readed->dataLen > 0){\r\n                   // 根据readed->data和readed->dataLen读取有效数据\r\n                   // 根据readed->msgType判断是完整数据，还是部分数据\r\n                   // 如果是部分数据，根据readed->packId将数据重组在一起\r\n              }\r\n              // delete readed;// readed在分发后会由服务器销毁，外部调用者无需清理操作 \r\n        }\r\n    }\r\n</pre>\r\n7、服务器发数据给客户端<br/>\r\n<pre>\r\n    服务器没有发送数据给客户端的方法，如果需要，按下列步骤处理：\r\n    1) 在客户端建立新的服务端(S2)\r\n    2) 在服务端建立与S2对应的客户端(C2)，注意serverName和blockSize要与S2一致\r\n    3) 使用C2与S2通信\r\n </pre>   \r\n\r\n### 在Java中使用FastIPC\r\nY<pre>\r\n    // 加载dll\r\n    System.loadLibrary(\"FastIPC_JNI\");\r\n    。。。。。。。。。。。。\r\n\r\n    // 创建服务端\r\n    this.server = new FastIPCServer();\r\n    this.serverName = FastIPCNative.genServerName();\r\n    this.blockSize = 5;\r\n    server.create(serverName, blockSize);\r\n    server.setListener(new FastIPCReadListener(){\r\n        @Override\r\n\tpublic void OnRead(int msgType, String packId, byte[] data) {\r\n\t   System.out.println(\"msgType = \" + msgType \r\n                          + \" packId = \" + packId\r\n                          +\" data = \" + new String(data, \"utf-8\"));\r\n\t}\r\n    });\r\n    new Thread() {\r\n       @Override\r\n       public void run() {\r\n          server.startRead();\r\n       }\r\n    }.start();\r\n\r\n    。。。。。。。。。。。。\r\n    // 创建客户端\r\n    client = new FastIPCClient();\r\n    client.create(FastIPCNative.genServerName(this.serverName), this.blockSize);\r\n    client.write(“客户端建好了。。。。”);// 发送数据\r\n</pre>\r\nJava建立的Server/Client可以和C++等进程建立的Server/Client进行交互通信\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}